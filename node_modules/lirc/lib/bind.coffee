
lirc = require './lirc'

{type} = Function


visited = []

bind = (val, newThis = this, depth = 1) ->
	visited = []

	return bind.set val, newThis, depth

bind.bind = bind

bind.set = (val, newThis = this, depth = 1) ->
	objType = type val
	isObj	= objType is 'object'
	isFn	= objType is 'function'

	if isObj or isFn
		return val if val in visited
		visited.push val

		if isFn
			if bind.countProps( val ) >= 1
				return bind.func val, newThis, depth
			else
				return bind.wrap val, newThis

		else if isObj
			return bind.obj val, newThis, depth

	return val

bind.wrap = (fn, newThis) ->
	return () -> fn.apply newThis, arguments

bind.obj = (obj, newThis, depth = 1) ->
	return obj if depth < 1

	--depth

	for own key of obj
		obj[key] = bind.set obj[key], newThis, depth

	return obj

bind.func = (func, newThis, depth = 1) ->
	return func if depth < 1

	--depth

	newFunc = bind.wrap func, newThis

	for own key of func
		newFunc[key] = bind.set func[key], newThis, depth

	return newFunc

bind.countProps = (fn, count = 0) ->
	++count for own key of fn

	return count

# If "emitter" is set, it will bind the event to it
bind.listenerMap = (obj, newThis, emitter = false) ->
	objType = type( obj )

	if objType is 'object'
		obj[key] = arguments.callee obj[key], newThis, emitter for key of obj
		
	else if objType is 'array'
		for key of obj
			obj[key][1] = bind.set obj[key][1], newThis

			if emitter
				emitter.on obj[key][0], obj[key][1]

	return obj


lirc.bind		=
module.exports	= bind