
require './format'

lirc = require './lirc'

{merge, clone} = Object
{type} = Function


msgBuffer		= null
mappingIndexes	= {}

parse = {
	data: (text = '') ->
		return text if type( text ) isnt 'string'

		lines = text.split '\r\n'

		if msgBuffer
			lines[0]	= msgBuffer + lines[0]
			msgBuffer	= null

		if not text.match /\r\n$/
			msgBuffer	= lines[-1..][0]
		else
			lines.pop()

		for line in lines
			msg = lirc.format.msg line

			for name, mapping of lirc.mappings
				parse.mapping name, mapping, msg

			lirc.emit 'msg', msg

		return msg

	mapping: (name, mapping, msg) ->
		index = mappingIndexes[ name ]?[ msg.cmd ]

		if index
			msg = mapping[ index ][1]( msg )
		else
			if name not of mappingIndexes then mappingIndexes[ name ] = {}

			for args, aryIndex in mapping
				if not msg.cmd?
					args[1]( msg )
					continue

				isRegexp = type( args[0] ) is 'regexp'

				if ( isRegexp and msg.cmd.match args[0] ) or args[0] is msg.cmd
					if msg.cmd not of mappingIndexes[ name ]
						mappingIndexes[ name ][ msg.cmd ] = aryIndex

					args[1]( msg )
					break

		return msg

	bindListeners: (obj, emitter) ->
		objType = type( obj )

		if objType is 'object'
			for key of obj
				emitter.on key, obj[key]
			
		else if objType is 'array'
			for key of obj
				emitter.on obj[key][0], obj[key][1]

		return emitter
}


lirc.parse		=
module.exports	= parse