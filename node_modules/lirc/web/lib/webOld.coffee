http		= require('http')
util		= require('util')
events		= require('events')
path		= require('path')
$			= require('./config')
router		= require('router')
templater	= require('templater')
lactate		= require('lactate')
io			= require('socket.io')

module.exports = (newCfg) ->
	format.merge($, newCfg)

	templater	= new templater($.dir.base, $.templating)

	lactate		= lactate.dir($.dir.static, $.lactate)

	router		= new router()
	router.load($.dir.routes)

	return calls

calls = {
	start : (ircEmitter, port, host) ->
		return false if ! ircEmitter or ! port

		host = host or 'localhost'

		templater.init()

		try
			server = http.createServer(route)

			io = io.listen(server, { log: false })
			server.listen(port, host)

			io.sockets.on('connection', (socket) ->
				console.log('Web, New connection')

				socket.on('data', (msg) ->
					emitter.emit('data', msg)
				)
			)

			ircEmitter.on('data', (msg) ->
				io.sockets.emit('data', msg)
			)

		catch error
			console.log('Web front-end failed to start: ', error)
			return false

		console.log('Web front-end started on ', port)

		return true

	isStarted : false
}

Emitter = () ->
	events.EventEmitter.call(this)
	return true

util.inherits(Emitter, events.EventEmitter)

emitter					=
calls.emitter			= new Emitter()

route = (req, res) ->
	route = router.match(req)

	if route.name is 'static'
		filePath = route.path.file or route.splats.join('.')
		return lactate.serve(filePath, req, res)

	templater.rehash() # Dev environment only, adds 20-60ms to loadtime per query

	logic(req, res, route)

logic = (req, res, route) ->
	name		= route.name
	path		= route.path
	query		= route.query

	data		= { $ : $ }
	template	= 'core'
	code		= 200
	headers		= {
		'server'		: 'node.js'
		'content-type'	: 'text/html; charset=utf-8'
	}

	if name is '404' or ! templater.isLoaded(template)
		template	= '404'
		code		= 404

	console.log("Web, template logic: #{template}")
	
	templater.respond(res, {
		template	: template
		headers		: headers
		code		: code
		data		: data
	})

format = {
	merge : (obj1, obj2) ->
		for own key of obj2
			if (
				obj2[key] instanceof Object and
				obj1[key] and
				obj1[key] instanceof Object
			)
				format.merge(obj1[key], obj2[key])
			else
				obj1[key] = obj2[key]
				
		return obj1
}

