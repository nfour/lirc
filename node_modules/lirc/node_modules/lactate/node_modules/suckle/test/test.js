
var Suckle = require('../lib/suckle')

var vows = require('vows')
var assert = require('assert')

var ReadStream = require('./readstream')
var WriteStream = require('./writestream')

var createMulticast = function(num, cb) {

    var suckle = new Suckle()
    var completed = []

    var writeCallback = function(err, data) {
        if (err) return cb(err)
        completed.push(data.length)
        if (completed.length === num) {
            return cb(null, completed)
        }
    }

    var streams = []
    for (var i=0;i<num;i++) {
        ;(function() {
            var ws = new WriteStream(writeCallback)
            ws.on('error', cb)
            streams.push(ws)
        })()
    }

    streams.forEach(function(stream) {
        suckle.pipe(stream)
    })

    var rs = new ReadStream(2048, 1024)

    rs.pipe(suckle)
    rs.init()

    rs.on('error', cb)
    suckle.on('error', cb)

}

var validStream = {
    'new Suckle': {
        topic:new Suckle(),
        'has writable property':function(val) {
            assert.strictEqual(val.writable, true)
        },
        'has write method':function(val) {
            assert.strictEqual(typeof val.write, 'function')
        },
        'has end method':function(val) {
            assert.strictEqual(typeof val.end, 'function')
        }
    }
}

var unicast = {
    'Data length 1024 chunksize 1024': {
        topic:function() {
            var ws = new WriteStream(this.callback)
            var suckle = new Suckle(ws)
            var rs = new ReadStream(1024, 1024)
            rs.pipe(suckle)
            rs.init()
        },
        'was streamed':function(val) {
            assert.ok(val)
        },
        'has length 1024':function(val) {
            assert.strictEqual(val.length, 1024)
        }
    },
    'Data length 102400 chunksize 8': {
        topic:function() {
            var ws = new WriteStream(this.callback)
            var suckle = new Suckle(ws)
            var rs = new ReadStream(102400, 8)
            rs.pipe(suckle)
            rs.init()
        },
        'was streamed':function(val) {
            assert.ok(val)
        },
        'has length 102400':function(val) {
            assert.strictEqual(val.length, 102400)
        }
    }
}

var multicast = {
    'Two streams': {
        topic:function() {
            createMulticast(2, this.callback)
        },
        'should not err':function(err, val) {
            assert.ifError(err)
        },
        'were streamed':function(err, val) {
            assert.strictEqual(val.length, 2)
        },
        'received complete data':function(err, val) {
            assert.ok(val.every(function(i) {
                return i === 2048
            }))
        }
    },
    'Ten streams': {
        topic:function() {
            createMulticast(10, this.callback)
        },
        'should not err':function(err, val) {
            assert.ifError(err)
        },
        'were streamed':function(err, val) {
            assert.strictEqual(val.length, 10)
        },
        'received complete data':function(err, val) {
            assert.ok(val.every(function(i) {
                return i === 2048
            }))
        }
    },
    'One hundred streams': {
        topic:function() {
            createMulticast(100, this.callback)
        },
        'should not err':function(err, val) {
            assert.ifError(err)
        },
        'were streamed':function(err, val) {
            assert.strictEqual(val.length, 100)
        },
        'received complete data':function(err, val) {
            assert.ok(val.every(function(i) {
                return i === 2048
            }))
        }
    }
}

var streamCallback = {
    'Stream Callback (Constructor)': {
        topic:function() {
            var self = this

            var suckle = new Suckle(function(data) {
                return self.callback(null, data)
            })

            var rs = new ReadStream(2048, 1024)

            suckle.on('error', this.callback)
            rs.on('error', this.callback)

            rs.pipe(suckle)
            rs.init()
        },
        'should not err':function(err, res) {
            assert.ifError(err)
        },
        'supplied accumulated data':function(err, res) {
            assert.strictEqual(res.length, 2048)
        }
    },
    'Stream Callback (oncomplete)': {
        topic:function() {
            var self = this

            var suckle = new Suckle()

            suckle.oncomplete(function(data) {
                return self.callback(null, data)
            })

            var rs = new ReadStream(2048, 1024)

            suckle.on('error', this.callback)
            rs.on('error', this.callback)

            rs.pipe(suckle)
            rs.init()
        },
        'should not err':function(err, res) {
            assert.ifError(err)
        },
        'supplied accumulated data':function(err, res) {
            assert.strictEqual(res.length, 2048)
        }
    },
    'Stream Callback With Unicast': {
        topic:function() {
            var self = this

            var suckle = new Suckle()

            suckle.oncomplete(function(data) {
                return self.callback(null, data)
            })

            var ws = new WriteStream()
            suckle.pipe(ws)

            var rs = new ReadStream(2048, 1024)

            suckle.on('error', this.callback)
            rs.on('error', this.callback)

            rs.pipe(suckle)
            rs.init()
        },
        'should not err':function(err, res) {
            assert.ifError(err)
        },
        'supplied accumulated data':function(err, res) {
            assert.strictEqual(res.length, 2048)
        }
    }
}

vows.describe('Validate Writable Stream')
.addBatch(validStream)
.export(module)

vows.describe('Unicast')
.addBatch(unicast)
.export(module)

vows.describe('Multicast')
.addBatch(multicast)
.export(module)

vows.describe('Stream Callback')
.addBatch(streamCallback)
.export(module)
